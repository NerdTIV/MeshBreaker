#!/usr/bin/env python3

import argparse
import logging
import os
import random
import time
from typing import Iterable, Optional, Tuple

LOG_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", "..", "logs"))
os.makedirs(LOG_DIR, exist_ok=True)
LOG_FILE = os.path.join(LOG_DIR, "physical_hardware_fuzz.log")

logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] %(levelname)s: %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILE),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

PATTERNS = ("zeros", "ones", "alternating", "incrementing", "random", "mixed")


def build_payload(length: int, pattern: str, rng: random.Random) -> bytes:
    if length <= 0:
        return b""

    if pattern == "zeros":
        return b"\x00" * length
    if pattern == "ones":
        return b"\xFF" * length
    if pattern == "alternating":
        base = b"\xAA\x55" * (length // 2)
        return base + (b"\xAA" if length % 2 else b"")
    if pattern == "incrementing":
        return bytes([i % 256 for i in range(length)])
    if pattern == "random":
        return bytes([rng.randint(0, 255) for _ in range(length)])

    raise ValueError(f"Unknown pattern: {pattern}")


def iter_payloads(count: int, min_len: int, max_len: int, pattern: str, seed: Optional[int]) -> Iterable[Tuple[str, bytes]]:
    rng = random.Random(seed)
    for _ in range(count):
        length = min_len if min_len == max_len else rng.randint(min_len, max_len)
        selected = pattern
        if pattern == "mixed":
            selected = rng.choice([p for p in PATTERNS if p != "mixed"])
        yield selected, build_payload(length, selected, rng)


def fuzz_uart(args: argparse.Namespace) -> int:
    try:
        import serial
    except ImportError:
        logger.error("pyserial is required for UART. Install: pip install pyserial")
        return 1

    parity_map = {
        "none": serial.PARITY_NONE,
        "even": serial.PARITY_EVEN,
        "odd": serial.PARITY_ODD,
    }
    stopbits_map = {
        "1": serial.STOPBITS_ONE,
        "1.5": serial.STOPBITS_ONE_POINT_FIVE,
        "2": serial.STOPBITS_TWO,
    }
    bytesize_map = {
        "5": serial.FIVEBITS,
        "6": serial.SIXBITS,
        "7": serial.SEVENBITS,
        "8": serial.EIGHTBITS,
    }

    logger.info(f"Opening UART on {args.port} @ {args.baud} baud")
    with serial.Serial(
        port=args.port,
        baudrate=args.baud,
        parity=parity_map[args.parity],
        stopbits=stopbits_map[args.stopbits],
        bytesize=bytesize_map[args.bytesize],
        timeout=args.timeout,
        write_timeout=args.write_timeout,
    ) as ser:
        for idx, (pattern, payload) in enumerate(iter_payloads(args.count, args.min_len, args.max_len, args.pattern, args.seed), start=1):
            data = payload + (args.newline.encode("ascii") if args.newline else b"")
            logger.info(f"[UART] {idx}/{args.count} pattern={pattern} len={len(data)}")
            if not args.dry_run:
                ser.write(data)
                if args.read_len > 0:
                    _ = ser.read(args.read_len)
            time.sleep(args.delay)

    return 0


def fuzz_i2c(args: argparse.Namespace) -> int:
    if args.backend == "smbus":
        try:
            from smbus2 import SMBus, i2c_msg
        except ImportError:
            logger.error("smbus2 is required for I2C (SMBus). Install: pip install smbus2")
            return 1

        logger.info(f"Opening I2C SMBus {args.bus} to address 0x{args.address:02X}")
        with SMBus(args.bus) as bus:
            for idx, (pattern, payload) in enumerate(iter_payloads(args.count, args.min_len, args.max_len, args.pattern, args.seed), start=1):
                logger.info(f"[I2C/SMBus] {idx}/{args.count} pattern={pattern} len={len(payload)}")
                if not args.dry_run:
                    bus.i2c_rdwr(i2c_msg.write(args.address, payload))
                    if args.read_len > 0:
                        read_msg = i2c_msg.read(args.address, args.read_len)
                        bus.i2c_rdwr(read_msg)
                time.sleep(args.delay)
        return 0

    if args.backend == "ftdi":
        try:
            from pyftdi.i2c import I2cController
        except ImportError:
            logger.error("pyftdi is required for I2C (FTDI). Install: pip install pyftdi")
            return 1

        ctrl = I2cController()
        try:
            logger.info(f"Opening I2C FTDI {args.ftdi_url} to address 0x{args.address:02X}")
            ctrl.configure(args.ftdi_url, frequency=args.frequency)
            port = ctrl.get_port(args.address)
            for idx, (pattern, payload) in enumerate(iter_payloads(args.count, args.min_len, args.max_len, args.pattern, args.seed), start=1):
                logger.info(f"[I2C/FTDI] {idx}/{args.count} pattern={pattern} len={len(payload)}")
                if not args.dry_run:
                    port.write(payload)
                    if args.read_len > 0:
                        _ = port.read(args.read_len)
                time.sleep(args.delay)
        finally:
            ctrl.terminate()
        return 0

    logger.error(f"Unsupported I2C backend: {args.backend}")
    return 1


def fuzz_spi(args: argparse.Namespace) -> int:
    if args.backend == "spidev":
        try:
            import spidev
        except ImportError:
            logger.error("spidev is required for SPI (Linux). Install: pip install spidev")
            return 1

        spi = spidev.SpiDev()
        spi.open(args.bus, args.device)
        spi.max_speed_hz = args.speed
        spi.mode = args.mode
        spi.bits_per_word = args.bits
        try:
            logger.info(f"Opening SPI spidev bus={args.bus} device={args.device}")
            for idx, (pattern, payload) in enumerate(iter_payloads(args.count, args.min_len, args.max_len, args.pattern, args.seed), start=1):
                logger.info(f"[SPI/spidev] {idx}/{args.count} pattern={pattern} len={len(payload)}")
                if not args.dry_run:
                    spi.xfer2(list(payload))
                time.sleep(args.delay)
        finally:
            spi.close()
        return 0

    if args.backend == "ftdi":
        try:
            from pyftdi.spi import SpiController
        except ImportError:
            logger.error("pyftdi is required for SPI (FTDI). Install: pip install pyftdi")
            return 1

        ctrl = SpiController()
        try:
            logger.info(f"Opening SPI FTDI {args.ftdi_url} cs={args.cs}")
            ctrl.configure(args.ftdi_url)
            port = ctrl.get_port(cs=args.cs, freq=args.speed, mode=args.mode)
            for idx, (pattern, payload) in enumerate(iter_payloads(args.count, args.min_len, args.max_len, args.pattern, args.seed), start=1):
                logger.info(f"[SPI/FTDI] {idx}/{args.count} pattern={pattern} len={len(payload)}")
                if not args.dry_run:
                    port.write(payload)
                time.sleep(args.delay)
        finally:
            ctrl.terminate()
        return 0

    logger.error(f"Unsupported SPI backend: {args.backend}")
    return 1


def build_parser() -> argparse.ArgumentParser:
    common = argparse.ArgumentParser(add_help=False)
    common.add_argument("--count", type=int, default=50, help="Number of payloads to send")
    common.add_argument("--min-len", type=int, default=1, help="Minimum payload length")
    common.add_argument("--max-len", type=int, default=64, help="Maximum payload length")
    common.add_argument("--pattern", choices=PATTERNS, default="mixed", help="Payload pattern")
    common.add_argument("--delay", type=float, default=0.05, help="Delay between payloads (seconds)")
    common.add_argument("--seed", type=int, default=None, help="Random seed")
    common.add_argument("--dry-run", action="store_true", help="Log payloads without sending")

    parser = argparse.ArgumentParser(description="Physical Hardware Fuzzer (UART/I2C/SPI)")
    subparsers = parser.add_subparsers(dest="mode", required=True)

    uart = subparsers.add_parser("uart", parents=[common], help="Fuzz a local UART (USB-Serial)")
    uart.add_argument("--port", required=True, help="Serial port (e.g., COM3 or /dev/ttyUSB0)")
    uart.add_argument("--baud", type=int, default=115200, help="Baud rate")
    uart.add_argument("--parity", choices=["none", "even", "odd"], default="none")
    uart.add_argument("--stopbits", choices=["1", "1.5", "2"], default="1")
    uart.add_argument("--bytesize", choices=["5", "6", "7", "8"], default="8")
    uart.add_argument("--timeout", type=float, default=0.5, help="Read timeout (seconds)")
    uart.add_argument("--write-timeout", type=float, default=0.5, help="Write timeout (seconds)")
    uart.add_argument("--read-len", type=int, default=0, help="Read length after write (bytes)")
    uart.add_argument("--newline", default="", help="Optional line ending (e.g., \\r\\n)")

    i2c = subparsers.add_parser("i2c", parents=[common], help="Fuzz a local I2C bus")
    i2c.add_argument("--backend", choices=["smbus", "ftdi"], default="smbus")
    i2c.add_argument("--address", type=lambda v: int(v, 0), required=True, help="I2C address (e.g., 0x50)")
    i2c.add_argument("--read-len", type=int, default=0, help="Read length after write (bytes)")
    i2c.add_argument("--frequency", type=int, default=100000, help="I2C frequency (FTDI)")
    i2c.add_argument("--bus", type=int, default=1, help="I2C bus number (SMBus)")
    i2c.add_argument("--ftdi-url", default="ftdi://ftdi:232h/1", help="FTDI URL (pyftdi)")

    spi = subparsers.add_parser("spi", parents=[common], help="Fuzz a local SPI bus")
    spi.add_argument("--backend", choices=["spidev", "ftdi"], default="spidev")
    spi.add_argument("--bus", type=int, default=0, help="SPI bus (spidev)")
    spi.add_argument("--device", type=int, default=0, help="SPI device/CS (spidev)")
    spi.add_argument("--mode", type=int, choices=[0, 1, 2, 3], default=0, help="SPI mode")
    spi.add_argument("--bits", type=int, default=8, help="Bits per word (spidev)")
    spi.add_argument("--speed", type=int, default=1000000, help="SPI speed (Hz)")
    spi.add_argument("--cs", type=int, default=0, help="Chip select (FTDI)")
    spi.add_argument("--ftdi-url", default="ftdi://ftdi:232h/1", help="FTDI URL (pyftdi)")

    return parser


def main() -> int:
    parser = build_parser()
    args = parser.parse_args()

    if args.min_len < 0 or args.max_len < 0 or args.max_len < args.min_len:
        logger.error("Invalid payload length range.")
        return 1

    if args.mode == "uart":
        return fuzz_uart(args)
    if args.mode == "i2c":
        return fuzz_i2c(args)
    if args.mode == "spi":
        return fuzz_spi(args)

    logger.error(f"Unsupported mode: {args.mode}")
    return 1


if __name__ == "__main__":
    raise SystemExit(main())
