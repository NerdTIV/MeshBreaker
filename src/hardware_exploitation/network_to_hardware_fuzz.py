#!/usr/bin/env python3

import sys
import os
import time
import struct
import random
import socket
import logging
from typing import List, Tuple, Optional

LOG_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", "..", "logs"))
os.makedirs(LOG_DIR, exist_ok=True)
LOG_FILE = os.path.join(LOG_DIR, "network_hardware_fuzzer.log")

logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] %(levelname)s: %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILE),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


class HardwareFuzzer:

    def __init__(self, target_ip: str, target_port: int = 8888):
        self.target_ip = target_ip
        self.target_port = target_port
        self.crashes = []
        self.anomalies = []

    def fuzz_uart_interface(self) -> List[bytes]:
        logger.info("Fuzzing UART interface...")
        test_cases = []
        for size in [256, 512, 1024, 2048]:
            payload = b'A' * size + b'\r\n'
            test_cases.append(('uart_overflow', payload))
        commands = [
            b'AT\x00COMMANDS\r\n', b'+++ATH0\r\n', b'\xFF\xF3\xFF\xFD\x06',
            b'!@#$%^&*()' * 10 + b'\r\n', b'$(reboot)\r\n', b'`cat /etc/passwd`\r\n',
        ]
        for cmd in commands:
            test_cases.append(('uart_cmd_injection', cmd))
        test_cases.append(('uart_no_terminator', b'A' * 100))
        test_cases.append(('uart_multi_term', b'test\r\n\r\n\r\n' * 10))
        for _ in range(10):
            binary_data = bytes([random.randint(0, 255) for _ in range(64)])
            test_cases.append(('uart_binary', binary_data))
        logger.info(f"Generated {len(test_cases)} UART test cases")
        return test_cases

    def fuzz_spi_interface(self) -> List[bytes]:
        logger.info("Fuzzing SPI interface...")
        test_cases = []
        for size in [256, 512, 1024]:
            payload = bytes([random.randint(0, 255) for _ in range(size)])
            test_cases.append(('spi_overflow', payload))
        invalid_cmds = [0xFF, 0x00, 0xAA, 0x55, 0xDE, 0xAD]
        for cmd in invalid_cmds:
            payload = struct.pack('B', cmd) + b'\x00' * 16
            test_cases.append(('spi_invalid_cmd', payload))
        for addr in [0xFFFFFFFF, 0x00000000, 0x80000000, 0x08000000]:
            payload = struct.pack('<BI', 0x03, addr) + b'\x00' * 10
            test_cases.append(('spi_addr_boundary', payload))
        logger.info(f"Generated {len(test_cases)} SPI test cases")
        return test_cases

    def fuzz_i2c_interface(self) -> List[bytes]:
        logger.info("Fuzzing I2C interface...")
        test_cases = []
        for addr in [0x00, 0x01, 0x02, 0x78, 0x7F, 0xFF]:
            payload = struct.pack('B', addr << 1) + b'\x00\x00'
            test_cases.append(('i2c_invalid_addr', payload))
        for size in [64, 128, 256]:
            payload = struct.pack('B', 0x50 << 1) + bytes([random.randint(0, 255) for _ in range(size)])
            test_cases.append(('i2c_overflow', payload))
        for reg in [0xFF, 0xFE, 0xFD]:
            payload = struct.pack('BB', 0x50 << 1, reg) + b'\xAA' * 32
            test_cases.append(('i2c_invalid_reg', payload))
        logger.info(f"Generated {len(test_cases)} I2C test cases")
        return test_cases

    def fuzz_dma_controller(self) -> List[bytes]:
        logger.info("Fuzzing DMA controller...")
        test_cases = []
        for length in [0x00000000, 0xFFFFFFFF, 0x80000000]:
            descriptor = struct.pack('<III', 0x20000000, 0x20001000, length) + b'\xFF\xFF\xFF\xFF'
            test_cases.append(('dma_invalid_length', descriptor))
        protected_addrs = [0x00000000, 0xE0000000, 0xF0000000, 0xFFFFFFFF]
        for addr in protected_addrs:
            descriptor = struct.pack('<III', 0x20000000, addr, 256) + b'\x00\x00\x00\x00'
            test_cases.append(('dma_protected_addr', descriptor))
        descriptor = struct.pack('<III', 0x20000FF0, 0x20001000, 0x100) + b'\x01\x00\x00\x00'
        test_cases.append(('dma_wraparound', descriptor))
        logger.info(f"Generated {len(test_cases)} DMA test cases")
        return test_cases

    def fuzz_flash_controller(self) -> List[bytes]:
        logger.info("Fuzzing Flash controller...")
        test_cases = []
        for addr in [0x08000000, 0x08000100, 0x08007F00]:
            cmd = struct.pack('<BI', 0x02, addr) + b'\xAA' * 256
            test_cases.append(('flash_write_protected', cmd))
        for addr in [0x08000000, 0x08010000, 0x08020000]:
            cmd = struct.pack('<BI', 0x20, addr)
            test_cases.append(('flash_erase_locked', cmd))
        for sector in [0xFF, 0xFE, 0x80]:
            cmd = struct.pack('<BB', 0x20, sector)
            test_cases.append(('flash_invalid_sector', cmd))
        option_bytes = struct.pack('<IIII', 0xFFFFFFFF, 0x00000000, 0xAAAAAAAA, 0x55555555)
        test_cases.append(('flash_option_corrupt', option_bytes))
        logger.info(f"Generated {len(test_cases)} Flash test cases")
        return test_cases

    def fuzz_timer_peripherals(self) -> List[bytes]:
        logger.info("Fuzzing Timer peripherals...")
        test_cases = []
        for arr in [0x00000000, 0xFFFFFFFF, 0x00000001]:
            config = struct.pack('<III', arr, 0, 0)
            test_cases.append(('timer_extreme_arr', config))
        for psc in [0xFFFF, 0x0000, 0x8000]:
            config = struct.pack('<III', 1000, psc, 500)
            test_cases.append(('timer_prescaler', config))
        for ccr in [0xFFFFFFFF, 0x80000000]:
            config = struct.pack('<III', 1000, 0, ccr)
            test_cases.append(('pwm_overflow', config))
        logger.info(f"Generated {len(test_cases)} Timer test cases")
        return test_cases

    def fuzz_watchdog_timer(self) -> List[bytes]:
        logger.info("Fuzzing Watchdog timer...")
        test_cases = []
        disable_keys = [0xAAAA, 0x5555, 0xCCCC, 0xFFFF]
        for key in disable_keys:
            payload = struct.pack('<H', key)
            test_cases.append(('wdt_disable_bypass', payload))
        for reload in [0x0000, 0xFFFF, 0x0001, 0xFFF0]:
            payload = struct.pack('<H', reload)
            test_cases.append(('wdt_invalid_reload', payload))
        payload = struct.pack('<H', 0xAAAA) * 100
        test_cases.append(('wdt_flood', payload))
        logger.info(f"Generated {len(test_cases)} Watchdog test cases")
        return test_cases

    def fuzz_interrupt_controller(self) -> List[bytes]:
        logger.info("Fuzzing Interrupt controller...")
        test_cases = []
        for irq in [240, 255, 256, 0xFFFF]:
            payload = struct.pack('<H', irq) + b'\x01'
            test_cases.append(('nvic_invalid_irq', payload))
        for irq in range(10):
            payload = struct.pack('<HB', irq, 0x00)
            test_cases.append(('nvic_priority_inv', payload))
        payload = b'\xFF' * 32
        test_cases.append(('nvic_storm', payload))
        logger.info(f"Generated {len(test_cases)} NVIC test cases")
        return test_cases

    def send_hardware_payload(self, payload: bytes) -> Tuple[bool, Optional[str]]:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2.0)
            sock.connect((self.target_ip, self.target_port))
            sock.sendall(payload)
            try:
                sock.recv(1024)
                sock.close()
                return True, None
            except socket.timeout:
                sock.close()
                return False, "Timeout"
        except ConnectionRefusedError:
            return False, "Connection refused"
        except Exception as e:
            return False, f"Connection error: {str(e)}"

    def run_hardware_fuzzing(self):
        logger.info("Starting hardware fuzzing campaign...")
        logger.info(f"Target: {self.target_ip}:{self.target_port}")

        test_suites = [
            ("UART", self.fuzz_uart_interface()),
            ("SPI", self.fuzz_spi_interface()),
            ("I2C", self.fuzz_i2c_interface()),
            ("DMA", self.fuzz_dma_controller()),
            ("Flash", self.fuzz_flash_controller()),
            ("Timer", self.fuzz_timer_peripherals()),
            ("Watchdog", self.fuzz_watchdog_timer()),
            ("Interrupts", self.fuzz_interrupt_controller())
        ]
        total_tests = 0
        for suite_name, test_cases in test_suites:
            logger.info(f"Testing: {suite_name}")
            for idx, (case_name, payload) in enumerate(test_cases):
                total_tests += 1
                logger.info(f"  Running case {idx+1}/{len(test_cases)}: {case_name}")
                success, error = self.send_hardware_payload(payload)
                if error:
                    self.crashes.append(f"{suite_name} - {case_name}: {error}")
                    logger.warning(f"  Anomaly detected: {error}")
                time.sleep(0.05)

        logger.info("\nHardware Fuzzing Summary")
        logger.info(f"Total tests: {total_tests}")
        logger.info(f"Anomalies detected: {len(self.crashes)}")
        if self.crashes:
            logger.info("\nAnomaly details:")
            for crash in self.crashes[:10]:
                logger.info(f"  - {crash}")


def main():
    import argparse
    parser = argparse.ArgumentParser(description="Hardware Fuzzer")
    parser.add_argument('-t', '--target', required=True, help='Target IP')
    parser.add_argument('-p', '--port', type=int, default=8888, help='Target port')
    args = parser.parse_args()
    fuzzer = HardwareFuzzer(args.target, args.port)
    fuzzer.run_hardware_fuzzing()

if __name__ == "__main__":
    main()
